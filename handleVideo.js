// Import c·∫•u h√¨nh FFmpeg
import "./config/ffmpegConfig.js";

// Import c√°c modules
import fs from "fs";
import path from "path";
import { mergeVideosInBatches } from "./modules/batchProcessor.js";
import { addSubtitleToVideoEnhanced } from "./modules/subtitleProcessor.js";
import { checkVideoCompatibilityEnhanced } from "./modules/videoCompatibilityEnhanced.js";
import { mergeVideos, mergeVideosWithNormalization, mergeVideosWithReencode } from "./modules/videoMerger.js";
import { handleVideoError, showHelp } from "./utils/errorHandler.js";
import { findSubtitleFiles, findVideoFiles, generateOutputName } from "./utils/fileUtils.js";

console.log("üé¨ === B·∫ÆT ƒê·∫¶U GH√âP VIDEO ===");
console.log("üìã H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng:");
console.log("   1. ƒê·∫∑t t·∫•t c·∫£ video c·∫ßn gh√©p v√†o th∆∞ m·ª•c 'videos'");
console.log("   2. ƒê·∫∑t file subtitle (.srt) v√†o c√πng th∆∞ m·ª•c (t√πy ch·ªçn)");
console.log("   3. Ch·∫°y script n√†y");
console.log("   4. Video ƒë√£ gh√©p (v√† c√≥ subtitle) s·∫Ω ƒë∆∞·ª£c l∆∞u trong c√πng th∆∞ m·ª•c");
console.log("==========================================\n");

// H√†m d·ªçn d·∫πp c√°c file video g·ªëc sau khi gh√©p
async function cleanupSourceVideos(videoPaths, mergedPath, finalPath, folder) {
  console.log("\nüóëÔ∏è === D·ªåN D·∫∏P FILES ===");
  
  // T√≠nh t·ªïng dung l∆∞·ª£ng c√°c file g·ªëc
  let totalSourceSize = 0;
  const sourceFiles = [];
  
  videoPaths.forEach(videoPath => {
    const stats = fs.statSync(videoPath);
    totalSourceSize += stats.size;
    sourceFiles.push({
      name: path.basename(videoPath),
      path: videoPath,
      size: (stats.size / (1024 * 1024)).toFixed(2)
    });
  });
  
  const totalSourceSizeMB = (totalSourceSize / (1024 * 1024)).toFixed(2);
  const finalStats = fs.statSync(finalPath);
  const finalSizeMB = (finalStats.size / (1024 * 1024)).toFixed(2);
  
  console.log("üìä Th·ªëng k√™ dung l∆∞·ª£ng:");
  console.log(`   üìπ ${videoPaths.length} file g·ªëc: ${totalSourceSizeMB}MB`);
  console.log(`   üé¨ File cu·ªëi c√πng: ${finalSizeMB}MB`);
  console.log(`   üíæ Ti·∫øt ki·ªám: ${(totalSourceSize - finalStats.size > 0 ? '+' : '')}${((finalStats.size - totalSourceSize) / (1024 * 1024)).toFixed(2)}MB`);
  
  console.log("\nüìã Danh s√°ch file s·∫Ω b·ªã x√≥a:");
  sourceFiles.forEach((file, index) => {
    console.log(`   ${index + 1}. ${file.name} (${file.size}MB)`);
  });
  
  // Ki·ªÉm tra file trung gian (merged kh√¥ng c√≥ subtitle)
  const hasIntermediateFile = mergedPath !== finalPath && fs.existsSync(mergedPath);
  if (hasIntermediateFile) {
    const intermediateStats = fs.statSync(mergedPath);
    const intermediateSizeMB = (intermediateStats.size / (1024 * 1024)).toFixed(2);
    console.log(`   + File trung gian: ${path.basename(mergedPath)} (${intermediateSizeMB}MB)`);
  }
  
  console.log("\nü§î B·∫°n c√≥ mu·ªën d·ªçn d·∫πp c√°c file n√†y kh√¥ng?");
  console.log("   [Y] C√≥ - X√≥a t·∫•t c·∫£ file g·ªëc v√† file trung gian");
  console.log("   [S] Ch·ªâ x√≥a file g·ªëc - Gi·ªØ l·∫°i file trung gian");
  console.log("   [N] Kh√¥ng - Gi·ªØ l·∫°i t·∫•t c·∫£");
  
  // Trong m√¥i tr∆∞·ªùng Node.js, ch√∫ng ta s·∫Ω th√™m tham s·ªë command line cho vi·ªác n√†y
  // const cleanupMode = process.argv.find(arg => arg.startsWith('--cleanup='))?.split('=')[1] || 'ask';
  
  // if (cleanupMode === 'auto' || cleanupMode === 'yes' || cleanupMode === 'y') {
  //   await performCleanup(sourceFiles, mergedPath, finalPath, hasIntermediateFile, true);
  // } else if (cleanupMode === 'source' || cleanupMode === 's') {
  //   await performCleanup(sourceFiles, mergedPath, finalPath, hasIntermediateFile, false);
  // } else if (cleanupMode === 'no' || cleanupMode === 'n') {
  //   console.log("‚úÖ Gi·ªØ l·∫°i t·∫•t c·∫£ file");
  // } else {
  //   console.log("üí° S·ª≠ d·ª•ng tham s·ªë --cleanup=yes/source/no ƒë·ªÉ t·ª± ƒë·ªông h√≥a vi·ªác d·ªçn d·∫πp");
  //   console.log("   V√≠ d·ª•: node handleVideo.js --cleanup=yes");
  // }
  
  // Cleanup
  await performCleanup(sourceFiles, mergedPath, finalPath, hasIntermediateFile, true);

}

// H√†m th·ª±c hi·ªán d·ªçn d·∫πp
async function performCleanup(sourceFiles, mergedPath, finalPath, hasIntermediateFile, removeIntermediate) {
  console.log("\nüóëÔ∏è B·∫Øt ƒë·∫ßu d·ªçn d·∫πp...");
  
  let deletedCount = 0;
  let deletedSize = 0;
  
  // X√≥a c√°c file g·ªëc
  for (const file of sourceFiles) {
    try {
      const stats = fs.statSync(file.path);
      fs.unlinkSync(file.path);
      deletedCount++;
      deletedSize += stats.size;
      console.log(`   ‚úÖ ƒê√£ x√≥a: ${file.name}`);
    } catch (error) {
      console.log(`   ‚ùå L·ªói x√≥a ${file.name}: ${error.message}`);
    }
  }
  
  // X√≥a file trung gian n·∫øu ƒë∆∞·ª£c y√™u c·∫ßu
  if (removeIntermediate && hasIntermediateFile) {
    try {
      const stats = fs.statSync(mergedPath);
      fs.unlinkSync(mergedPath);
      deletedSize += stats.size;
      console.log(`   ‚úÖ ƒê√£ x√≥a file trung gian: ${path.basename(mergedPath)}`);
    } catch (error) {
      console.log(`   ‚ùå L·ªói x√≥a file trung gian: ${error.message}`);
    }
  }
  
  const deletedSizeMB = (deletedSize / (1024 * 1024)).toFixed(2);
  console.log(`\n‚úÖ D·ªçn d·∫πp ho√†n th√†nh!`);
  console.log(`   üìÅ ƒê√£ x√≥a: ${deletedCount} file`);
  console.log(`   üíæ Ti·∫øt ki·ªám: ${deletedSizeMB}MB dung l∆∞·ª£ng`);
  console.log(`   üé¨ Ch·ªâ c√≤n l·∫°i: ${path.basename(finalPath)}`);
}

async function combineVideo(customFolder = null, subtitleMethod = 'hardburn', forceNormalize = false) {
  const folder = customFolder ? path.resolve(customFolder) : path.join(process.cwd(), "videos");
  console.log(`üîç T√¨m ki·∫øm video trong th∆∞ m·ª•c: ${folder}`);
  
  const videoPaths = findVideoFiles(folder);
  const subtitlePaths = findSubtitleFiles(folder);
  
  if (videoPaths.length === 0) {
    console.log("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y video n√†o trong th∆∞ m·ª•c!");
    console.log("üìù H√£y ƒë·∫∑t c√°c file video v√†o th∆∞ m·ª•c 'videos'");
    return;
  }

  if (videoPaths.length < 2) {
    console.log("‚ö†Ô∏è C·∫ßn √≠t nh·∫•t 2 video ƒë·ªÉ gh√©p!");
    console.log(`üìä T√¨m th·∫•y: ${videoPaths.length} video`);
    videoPaths.forEach((path, index) => {
      console.log(`   ${index + 1}. ${path.split('\\').pop()}`);
    });
    return;
  }

  // Ki·ªÉm tra subtitle
  let subtitlePath = null;
  if (subtitlePaths.length > 0) {
    subtitlePath = subtitlePaths[0]; // S·ª≠ d·ª•ng subtitle ƒë·∫ßu ti√™n t√¨m th·∫•y
    console.log(`üìù T√¨m th·∫•y subtitle: ${subtitlePath.split('\\').pop()}`);
  } else {
    console.log(`üìù Kh√¥ng t√¨m th·∫•y file subtitle (.srt, .ass, .ssa, .vtt)`);
  }

  const outputPath = generateOutputName(folder, false);
  
  console.log(`üìπ S·∫Ω gh√©p ${videoPaths.length} video:`);
  videoPaths.forEach((path, index) => {
    const fileName = path.split('\\').pop();
    const stats = fs.statSync(path);
    const sizeMB = (stats.size / (1024 * 1024)).toFixed(2);
    console.log(`   ${index + 1}. ${fileName} (${sizeMB}MB)`);
  });
  
  console.log(`üíæ Output: ${outputPath.split('\\').pop()}`);

  try {
    console.log("üöÄ B·∫Øt ƒë·∫ßu gh√©p video...");
    let finalOutputPath = outputPath;
    
    // B∆∞·ªõc 0: Ki·ªÉm tra t∆∞∆°ng th√≠ch video (Enhanced)
    const compatibility = await checkVideoCompatibilityEnhanced(videoPaths);
    
    // B∆∞·ªõc 1: Quy·∫øt ƒë·ªãnh ph∆∞∆°ng ph√°p gh√©p d·ª±a tr√™n t∆∞∆°ng th√≠ch (TIMING SAFETY FIRST!)
    const totalSizeMB = compatibility.infos.reduce((sum, info) => sum + (info.size / (1024 * 1024)), 0);
    const shouldUseBatch = videoPaths.length > 15 || totalSizeMB > 5000;
    
    if (forceNormalize) {
      console.log("üîß Force normalize mode - s·ª≠ d·ª•ng chu·∫©n h√≥a format ƒë·ªÉ kh·∫Øc ph·ª•c timing issues...");
      await mergeVideosWithNormalization(videoPaths, outputPath);
    } else if (shouldUseBatch) {
      console.log(`üì¶ S·ªë l∆∞·ª£ng video l·ªõn (${videoPaths.length}) ho·∫∑c dung l∆∞·ª£ng l·ªõn (${totalSizeMB.toFixed(2)}MB)`);
      console.log("üì¶ S·ª≠ d·ª•ng ph∆∞∆°ng ph√°p batch processing...");
      await mergeVideosInBatches(videoPaths, outputPath, 5);
    } else if (compatibility.hasFpsMismatch || compatibility.hasTimingIssues) {
      // CRITICAL: FPS/Timing issues MUST use normalization to avoid 4.5-hour bug
      console.log("üö® CRITICAL TIMING ISSUES DETECTED!");
      console.log("üîß Using normalization to prevent 4.5-hour duration bug...");
      await mergeVideosWithNormalization(videoPaths, outputPath);
    } else if (compatibility.needsReencode || compatibility.hasResolutionMismatch) {
      console.log("üîÑ Using re-encode for compatibility...");
      await mergeVideosWithReencode(videoPaths, outputPath);
    } else {
      console.log("‚ö° Using copy codec (videos are compatible)...");
      try {
        await mergeVideos(videoPaths, outputPath);
      } catch (copyError) {
        console.log("‚ö†Ô∏è  Copy codec failed, fallback to re-encode...");
        try {
          await mergeVideosWithReencode(videoPaths, outputPath);
        } catch (reencodeError) {
          console.log("üîß Re-encode failed, using normalization (safest)...");
          await mergeVideosWithNormalization(videoPaths, outputPath);
        }
      }
    }
    
    // Hi·ªÉn th·ªã th√¥ng tin file ƒë√£ gh√©p
    const mergedStats = fs.statSync(outputPath);
    const mergedSizeMB = (mergedStats.size / (1024 * 1024)).toFixed(2);
    console.log(`‚úÖ Gh√©p video ho√†n th√†nh: ${outputPath.split('\\').pop()} (${mergedSizeMB}MB)`);
    
    // B∆∞·ªõc 2: G·∫Øn subtitle n·∫øu c√≥
    if (subtitlePath) {
      const subtitleOutputPath = generateOutputName(folder, true);
      console.log(`\nüìù B·∫Øt ƒë·∫ßu g·∫Øn subtitle (ph∆∞∆°ng ph√°p: ${subtitleMethod})...`);
      
      await addSubtitleToVideoEnhanced(outputPath, subtitlePath, subtitleOutputPath, subtitleMethod);
      
      // Hi·ªÉn th·ªã th√¥ng tin file c√≥ subtitle
      const subtitleStats = fs.statSync(subtitleOutputPath);
      const subtitleSizeMB = (subtitleStats.size / (1024 * 1024)).toFixed(2);
      console.log(`‚úÖ File v·ªõi subtitle: ${subtitleOutputPath.split('\\').pop()} (${subtitleSizeMB}MB)`);
      
      finalOutputPath = subtitleOutputPath;
      
      // T√πy ch·ªçn: X√≥a file trung gian (ch·ªâ c√≥ video, ch∆∞a c√≥ subtitle)
      console.log(`üóëÔ∏è B·∫°n c√≥ mu·ªën x√≥a file trung gian kh√¥ng c√≥ subtitle kh√¥ng? (${outputPath.split('\\').pop()})`);
    }
    
    // Hi·ªÉn th·ªã k·∫øt qu·∫£ cu·ªëi c√πng
    const finalStats = fs.statSync(finalOutputPath);
    const finalSizeMB = (finalStats.size / (1024 * 1024)).toFixed(2);
    console.log(`\nüéâ HO√ÄN TH√ÄNH! File cu·ªëi c√πng: ${finalOutputPath.split('\\').pop()} (${finalSizeMB}MB)`);
    
    // B∆∞·ªõc 3: T√πy ch·ªçn d·ªçn d·∫πp c√°c file video g·ªëc
    await cleanupSourceVideos(videoPaths, outputPath, finalOutputPath, folder);
    
  } catch (err) {
    handleVideoError(err);
  }
}

// X·ª≠ l√Ω tham s·ªë command line
const args = process.argv.slice(2);
const customFolder = args.find(arg => arg.startsWith('--folder='))?.split('=')[1];
const subtitleMethod = args.find(arg => arg.startsWith('--subtitle='))?.split('=')[1] || 'hardburn';
const forceNormalize = args.includes('--normalize') || args.includes('--fix-timing');
const helpFlag = args.includes('--help') || args.includes('-h');

if (helpFlag) {
  showHelp();
  process.exit(0);
}

// Ch·∫°y ch∆∞∆°ng tr√¨nh ch√≠nh
if (customFolder) {
  console.log(`üìÅ S·ª≠ d·ª•ng th∆∞ m·ª•c t√πy ch·ªânh: ${customFolder}`);
}

combineVideo(customFolder, subtitleMethod, forceNormalize).catch(err => {
  console.error("üí• L·ªói nghi√™m tr·ªçng:", err.message);
  process.exit(1);
});

export default combineVideo;